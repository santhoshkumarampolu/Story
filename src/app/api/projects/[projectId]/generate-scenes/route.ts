import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import { generateContent, trackTokenUsage } from '@/lib/gemini';

interface Scene {
  title: string;
  summary: string;
  // Add other relevant fields if needed, e.g., setting, charactersInScene, etc.
}

interface SceneOutput {
  title: string;
  summary: string;
  act: string;
  order: number;
  location: string;
  timeOfDay: string;
  characters: string[];
  goals: string;
  conflicts: string;
  emotionalBeats: string[];
  notes: string;
}

export async function POST(
  request: Request,
  { params }: { params: Promise<{ projectId: string }> } // Changed type here
) {
  try { // Added try block here to ensure projectId is resolved before use
    const { projectId } = await params; // Added this line to await and destructure projectId
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    if (!projectId) {
      return NextResponse.json({ error: 'Project ID is required' }, { status: 400 });
    }

    const project = await prisma.project.findUnique({
      where: { id: projectId },
      select: { userId: true, language: true, structureType: true },
    });

    if (!project || project.userId !== session.user.id) {
      return NextResponse.json({ error: 'Project not found or access denied' }, { status: 404 });
    }

    const body = await request.json();
    const { idea, logline, treatment, characters } = body;

    if (!idea || !logline || !treatment || !characters) {
      return NextResponse.json({ error: 'Idea, logline, treatment, and characters are required' }, { status: 400 });
    }

    const characterNames = characters.map((char: { name: string; description: string; }) => char.name).join(', ');

    const prompt = `Based on the following story details, generate a structured scene breakdown that follows the story's structure type (${project.structureType || 'three-act'}).

Story Details:
Idea: ${idea}
Logline: ${logline}
Treatment: ${treatment}

Characters:
${characterNames}

Generate 5-8 scenes that:
1. Follow proper story structure
2. Include all key characters appropriately
3. Build tension and conflict
4. Advance the plot
5. Develop character arcs

For each scene, provide:
- Title
- Summary (2-3 sentences)
- Act (act1, act2, act3)
- Order (chronological position)
- Location
- Time of Day
- Characters involved
- Scene Goals
- Conflicts
- Emotional Beats
- Notes

Format as JSON array:
[
  {
    "title": "Scene Title",
    "summary": "Scene description",
    "act": "act1",
    "order": 1,
    "location": "Scene location",
    "timeOfDay": "Time of day",
    "characters": ["Character1", "Character2"],
    "goals": "Scene goals",
    "conflicts": "Scene conflicts",
    "emotionalBeats": ["beat1", "beat2"],
    "notes": "Additional notes"
  }
]`;

    const systemPrompt = "You are a professional screenwriter who creates well-structured scene breakdowns. Always respond with valid JSON.";

    const result = await generateContent({
      model: 'flash',
      systemPrompt,
      userPrompt: prompt,
      maxTokens: 2500,
      temperature: 0.7,
    });

    const generatedContent = result.text;
    if (!generatedContent) {
      throw new Error('No content generated by Gemini.');
    }

    let scenes: SceneOutput[];
    try {
      // Clean the response - remove markdown code blocks if present
      let cleanedText = generatedContent.trim();
      if (cleanedText.startsWith("```json")) {
        cleanedText = cleanedText.slice(7);
      } else if (cleanedText.startsWith("```")) {
        cleanedText = cleanedText.slice(3);
      }
      if (cleanedText.endsWith("```")) {
        cleanedText = cleanedText.slice(0, -3);
      }
      cleanedText = cleanedText.trim();

      const parsedJson = JSON.parse(cleanedText);
      if (parsedJson.scenes && Array.isArray(parsedJson.scenes)) {
        scenes = parsedJson.scenes;
      } else if (Array.isArray(parsedJson)) {
        scenes = parsedJson;
      } else {
        throw new Error('Generated content is not in the expected format {scenes: [...]} or an array.');
      }
    } catch (e) {
      console.error('Error parsing Gemini response:', e);
      console.error('Raw Gemini response:', generatedContent);
      let specificError = 'Failed to parse scenes from Gemini response. The response was not valid JSON or not in the expected format.';
      if (e instanceof SyntaxError) {
        specificError = 'Failed to parse scenes: Gemini response was not valid JSON.';
      } else if (e instanceof Error) {
        specificError = `Failed to parse scenes: ${e.message}`;
      }
      throw new Error(specificError);
    }
    
    // Validate that scenes is an array and its elements have title and summary
    if (!Array.isArray(scenes) || !scenes.every(s => typeof s.title === 'string' && typeof s.summary === 'string')) {
        console.error('Parsed scenes are not in the correct format. Scenes:', scenes);
        throw new Error('Generated scenes are not in the expected format (array of objects with title and summary).');
    }

    // Transform snake_case keys to camelCase for consistency
    const transformedScenes = scenes.map((scene: any) => ({
      title: scene.title,
      summary: scene.summary,
      act: scene.act,
      order: scene.order,
      location: scene.location,
      timeOfDay: scene.time_of_day || scene.timeOfDay,
      characters: scene.characters,
      goals: scene.goals,
      conflicts: scene.conflicts,
      emotionalBeats: scene.emotional_beats || scene.emotionalBeats,
      notes: scene.notes,
    }));

    await trackTokenUsage({
      userId: session.user.id,
      projectId,
      model: result.model,
      promptTokens: result.usage.promptTokens,
      completionTokens: result.usage.completionTokens,
      totalTokens: result.usage.totalTokens,
      type: 'scenes',
      operationName: 'Scene Generation',
    });

    return NextResponse.json({ scenes: transformedScenes });

  } catch (error) {
    console.error('[API - Generate Scenes] Error:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';
    return NextResponse.json({ error: errorMessage, details: error instanceof Error ? error.stack : null }, { status: 500 });
  }
}
