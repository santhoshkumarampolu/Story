import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import { generateContent, trackTokenUsage } from '@/lib/gemini';
import { Prisma } from '@prisma/client';
import { checkUserSubscriptionAndUsage } from '@/lib/subscription';

interface CharacterOutput {
  name: string;
  description: string;
  motivation: string;
  backstory: string;
  arc: string;
  relationships: string;
  goals: string;
  conflicts: string;
  personality: string;
  traits: string[];
}

export async function POST(
  request: Request,
  { params }: { params: Promise<{ projectId: string }> }
) {
  const { projectId } = await params;
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    if (!projectId) {
      return NextResponse.json({ error: 'Project ID is required' }, { status: 400 });
    }

    // Parse request body to get story content
    const body = await request.json();
    const { idea: requestIdea, logline: requestLogline, synopsis: requestSynopsis, treatment: requestTreatment, language: requestLanguage } = body;

    const project = await prisma.project.findUnique({
      where: { id: projectId },
      select: { 
        userId: true, 
        language: true,
        idea: true,
        logline: true,
        blurb: true, // synopsis is stored in blurb field
        treatment: true
      },
    });

    if (!project || project.userId !== session.user.id) {
      return NextResponse.json({ error: 'Project not found or access denied' }, { status: 404 });
    }
    
    // Use values from request body if provided, otherwise fall back to database
    const idea = requestIdea || project.idea;
    const logline = requestLogline || project.logline;
    // Accept synopsis or treatment - they serve similar purposes for character generation
    const synopsis = requestSynopsis || requestTreatment || project.blurb || project.treatment;
    const language = requestLanguage || project.language;
    
    if (!idea || !logline || !synopsis) {
      return NextResponse.json({ error: 'Project must have an idea, logline, and synopsis/treatment before generating characters' }, { status: 400 });
    }

    // Subscription and usage check BEFORE OpenAI call
    // Estimate 2000 tokens for pre-check (same as max_tokens)
    const usageCheck = await checkUserSubscriptionAndUsage(session.user.id, 2000, 0);
    if (!usageCheck.allowed) {
      return NextResponse.json({ error: 'Token quota exceeded. Upgrade your plan or wait for next month.' }, { status: 403 });
    }

    const prompt = `Based on the following story details, generate a list of characters that would be essential to the narrative. For each character, provide a comprehensive profile.

Story Details:
Idea: ${idea}
Logline: ${logline}
Synopsis: ${synopsis}

Generate 3-5 main characters that:
1. Serve distinct narrative functions
2. Have clear motivations and goals
3. Face meaningful conflicts
4. Have potential for character development
5. Contribute to the story's themes

For each character, provide:
- Name
- Description (physical and personality traits)
- Motivation (what drives them)
- Backstory (key life events)
- Character Arc (how they change)
- Relationships (with other characters)
- Goals (what they want to achieve)
- Conflicts (internal and external)
- Personality (core traits and behaviors)
- Traits (specific characteristics)

Format the response as a JSON array of character objects:
[
  {
    "name": "Character Name",
    "description": "Character description",
    "motivation": "Character motivation",
    "backstory": "Character backstory",
    "arc": "Character arc",
    "relationships": "Character relationships",
    "goals": "Character goals",
    "conflicts": "Character conflicts",
    "personality": "Character personality",
    "traits": ["trait1", "trait2", "trait3"]
  }
]`;

    const systemPrompt = "You are a professional screenwriter who creates well-developed, compelling characters. Always respond with valid JSON. Keep character descriptions concise but impactful.";

    const result = await generateContent({
      model: 'flash',
      systemPrompt,
      userPrompt: prompt,
      maxTokens: 4000, // Increased to handle detailed character profiles
      temperature: 0.7,
    });

    const generatedContent = result.text;
    if (!generatedContent) {
      throw new Error('No content generated by Gemini.');
    }

    let characters: CharacterOutput[];
    try {
      // Clean the response - remove markdown code blocks if present
      let cleanedText = generatedContent.trim();
      if (cleanedText.startsWith("```json")) {
        cleanedText = cleanedText.slice(7);
      } else if (cleanedText.startsWith("```")) {
        cleanedText = cleanedText.slice(3);
      }
      if (cleanedText.endsWith("```")) {
        cleanedText = cleanedText.slice(0, -3);
      }
      cleanedText = cleanedText.trim();

      // Try to fix truncated JSON by finding complete character objects
      let parsedJson;
      try {
        parsedJson = JSON.parse(cleanedText);
      } catch (parseError) {
        // JSON is truncated, try to recover what we can
        console.log('Initial JSON parse failed, attempting to recover truncated response...');
        
        // Find the last complete character object (ends with })
        // Look for pattern: }, { or }, ] which indicates end of a character object
        const lastCompleteIndex = cleanedText.lastIndexOf('},');
        if (lastCompleteIndex > 0) {
          // Try to close the array after the last complete object
          cleanedText = cleanedText.substring(0, lastCompleteIndex + 1) + ']';
          try {
            parsedJson = JSON.parse(cleanedText);
            console.log('Successfully recovered truncated JSON with', Array.isArray(parsedJson) ? parsedJson.length : 0, 'characters');
          } catch (e) {
            // Still failed, try another approach - find last complete }
            const lastBrace = cleanedText.lastIndexOf('}');
            if (lastBrace > 0) {
              cleanedText = cleanedText.substring(0, lastBrace + 1) + ']';
              parsedJson = JSON.parse(cleanedText);
            }
          }
        }
        
        if (!parsedJson) {
          throw parseError;
        }
      }

      if (Array.isArray(parsedJson)) {
        characters = parsedJson;
      } else if (parsedJson.characters && Array.isArray(parsedJson.characters)) {
        characters = parsedJson.characters;
      } else {
        throw new Error('Generated content is not in the expected format (array of characters)');
      }
      
      // Filter out any incomplete character entries
      characters = characters.filter(char => char && char.name && char.description);
      
      if (characters.length === 0) {
        throw new Error('No valid characters found in response');
      }
    } catch (e) {
      console.error('Error parsing Gemini response:', e);
      console.error('Raw Gemini response:', generatedContent);
      throw new Error('Failed to parse characters from Gemini response');
    }

    // Helper function to convert any value to string
    const stringify = (value: any): string | null => {
      if (value === null || value === undefined) return null;
      if (typeof value === 'string') return value;
      if (Array.isArray(value)) return value.join(', ');
      if (typeof value === 'object') {
        // For objects like relationships: { Ananya: "...", Priya: "..." }
        return Object.entries(value)
          .map(([key, val]) => `${key}: ${val}`)
          .join('\n');
      }
      return String(value);
    };

    // Transform snake_case keys to camelCase for consistency and ensure all fields are strings
    const transformedCharacters = characters.map((char: any) => ({
      name: char.name,
      description: char.description,
      motivation: stringify(char.motivation),
      backstory: stringify(char.backstory || char.back_story),
      arc: stringify(char.arc || char.character_arc),
      relationships: stringify(char.relationships),
      goals: stringify(char.goals),
      conflicts: stringify(char.conflicts),
      personality: stringify(char.personality),
      traits: Array.isArray(char.traits) ? char.traits : (char.traits ? [char.traits] : []),
    }));

    // Validate character data
    if (!Array.isArray(transformedCharacters) || !transformedCharacters.every(char => 
      typeof char.name === 'string' && 
      typeof char.description === 'string'
    )) {
      throw new Error('Generated characters are not in the expected format');
    }

    // Create characters in the database
    const createdCharacters = await Promise.all(
      transformedCharacters.map(character => {
        const characterData = {
          name: character.name,
          description: character.description,
          motivation: character.motivation || null,
          backstory: character.backstory || null,
          arc: character.arc || null,
          relationships: character.relationships || null,
          goals: character.goals || null,
          conflicts: character.conflicts || null,
          personality: character.personality || null,
          traits: character.traits,
          imagePath: null,
          notes: null,
          projectId
        } as const;
        return prisma.character.create({
          data: characterData
        });
      })
    );

    // Update actual token usage after Gemini call
    await checkUserSubscriptionAndUsage(session.user.id, result.usage.totalTokens, 0);
    await trackTokenUsage({
      userId: session.user.id,
      projectId,
      model: result.model,
      promptTokens: result.usage.promptTokens,
      completionTokens: result.usage.completionTokens,
      totalTokens: result.usage.totalTokens,
      type: 'character_generation',
      operationName: 'Character Generation',
    });

    return NextResponse.json({ characters: createdCharacters });

  } catch (error) {
    console.error('[API - Generate Characters] Error:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';
    return NextResponse.json({ error: errorMessage, details: error instanceof Error ? error.stack : null }, { status: 500 });
  }
}

export async function GET(
  request: Request,
  { params }: { params: Promise<{ projectId: string }> }
) {
  return NextResponse.json(
    { error: 'GET method not allowed for this endpoint. Use POST to generate characters.' },
    { status: 405 }
  );
}
