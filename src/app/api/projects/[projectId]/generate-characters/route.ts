import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/lib/auth';
import { prisma } from '@/lib/prisma';
import OpenAI from 'openai';
import { trackTokenUsage } from '@/lib/openai';
import { Prisma } from '@prisma/client';
import { checkUserSubscriptionAndUsage } from '@/lib/subscription';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

interface CharacterOutput {
  name: string;
  description: string;
  motivation: string;
  backstory: string;
  arc: string;
  relationships: string;
  goals: string;
  conflicts: string;
  personality: string;
  traits: string[];
}

export async function POST(
  request: Request,
  { params }: { params: Promise<{ projectId: string }> }
) {
  const { projectId } = await params;
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    if (!projectId) {
      return NextResponse.json({ error: 'Project ID is required' }, { status: 400 });
    }

    // Parse request body to get story content
    const body = await request.json();
    const { idea: requestIdea, logline: requestLogline, treatment: requestTreatment, language: requestLanguage } = body;

    const project = await prisma.project.findUnique({
      where: { id: projectId },
      select: { 
        userId: true, 
        language: true,
        idea: true,
        logline: true,
        treatment: true
      },
    });

    if (!project || project.userId !== session.user.id) {
      return NextResponse.json({ error: 'Project not found or access denied' }, { status: 404 });
    }

    // Use values from request body if provided, otherwise fall back to database
    const idea = requestIdea || project.idea;
    const logline = requestLogline || project.logline;
    const treatment = requestTreatment || project.treatment;
    const language = requestLanguage || project.language;
    
    if (!idea || !logline || !treatment) {
      return NextResponse.json({ error: 'Project must have an idea, logline, and treatment before generating characters' }, { status: 400 });
    }

    // Subscription and usage check BEFORE OpenAI call
    // Estimate 2000 tokens for pre-check (same as max_tokens)
    const usageCheck = await checkUserSubscriptionAndUsage(session.user.id, 2000, 0);
    if (!usageCheck.allowed) {
      return NextResponse.json({ error: 'Token quota exceeded. Upgrade your plan or wait for next month.' }, { status: 403 });
    }

    const prompt = `Based on the following story details, generate a list of characters that would be essential to the narrative. For each character, provide a comprehensive profile.

Story Details:
Idea: ${idea}
Logline: ${logline}
Treatment: ${treatment}

Generate 3-5 main characters that:
1. Serve distinct narrative functions
2. Have clear motivations and goals
3. Face meaningful conflicts
4. Have potential for character development
5. Contribute to the story's themes

For each character, provide:
- Name
- Description (physical and personality traits)
- Motivation (what drives them)
- Backstory (key life events)
- Character Arc (how they change)
- Relationships (with other characters)
- Goals (what they want to achieve)
- Conflicts (internal and external)
- Personality (core traits and behaviors)
- Traits (specific characteristics)

Format the response as a JSON array of character objects:
[
  {
    "name": "Character Name",
    "description": "Character description",
    "motivation": "Character motivation",
    "backstory": "Character backstory",
    "arc": "Character arc",
    "relationships": "Character relationships",
    "goals": "Character goals",
    "conflicts": "Character conflicts",
    "personality": "Character personality",
    "traits": ["trait1", "trait2", "trait3"]
  }
]`;

    const completion = await openai.chat.completions.create({
      model: 'gpt-4',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 2000,
      temperature: 0.7,
    });

    const generatedContent = completion.choices[0]?.message?.content;
    if (!generatedContent) {
      throw new Error('No content generated by OpenAI.');
    }

    let characters: CharacterOutput[];
    try {
      // Try to parse the response as JSON
      const parsedJson = JSON.parse(generatedContent);
      if (Array.isArray(parsedJson)) {
        characters = parsedJson;
      } else if (parsedJson.characters && Array.isArray(parsedJson.characters)) {
        characters = parsedJson.characters;
      } else {
        throw new Error('Generated content is not in the expected format (array of characters)');
      }
    } catch (e) {
      console.error('Error parsing OpenAI response:', e);
      console.error('Raw OpenAI response:', generatedContent);
      throw new Error('Failed to parse characters from OpenAI response');
    }

    // Validate character data
    if (!Array.isArray(characters) || !characters.every(char => 
      typeof char.name === 'string' && 
      typeof char.description === 'string' &&
      typeof char.motivation === 'string' &&
      typeof char.backstory === 'string' &&
      typeof char.arc === 'string' &&
      typeof char.relationships === 'string' &&
      typeof char.goals === 'string' &&
      typeof char.conflicts === 'string' &&
      typeof char.personality === 'string' &&
      Array.isArray(char.traits)
    )) {
      throw new Error('Generated characters are not in the expected format');
      }

    // Create characters in the database
    const createdCharacters = await Promise.all(
      characters.map(character => {
        const characterData = {
          name: character.name,
          description: character.description,
          motivation: character.motivation || null,
          backstory: character.backstory || null,
          arc: character.arc || null,
          relationships: character.relationships || null,
          goals: character.goals || null,
          conflicts: character.conflicts || null,
          personality: character.personality || null,
          traits: character.traits,
          imagePath: null,
          notes: null,
          projectId
        } as const;
        return prisma.character.create({
          data: characterData
        });
      })
    );

    if (completion.usage) {
      // Update actual token usage after OpenAI call
      await checkUserSubscriptionAndUsage(session.user.id, completion.usage.total_tokens, 0);
    await trackTokenUsage({
        userId: session.user.id,
      projectId,
        model: completion.model,
        promptTokens: completion.usage.prompt_tokens,
        completionTokens: completion.usage.completion_tokens,
        totalTokens: completion.usage.total_tokens,
        type: 'character_generation',
        operationName: 'Character Generation',
        cost: ((completion.usage.prompt_tokens / 1000) * 0.0005) + ((completion.usage.completion_tokens / 1000) * 0.0015)
    });
    }

    return NextResponse.json({ characters: createdCharacters });

  } catch (error) {
    console.error('[API - Generate Characters] Error:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';
    return NextResponse.json({ error: errorMessage, details: error instanceof Error ? error.stack : null }, { status: 500 });
  }
}

export async function GET(
  request: Request,
  { params }: { params: Promise<{ projectId: string }> }
) {
  return NextResponse.json(
    { error: 'GET method not allowed for this endpoint. Use POST to generate characters.' },
    { status: 405 }
  );
}
