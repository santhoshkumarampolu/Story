import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/lib/auth";
import { prisma } from "@/lib/prisma";
import OpenAI from 'openai';
import { trackTokenUsage } from "@/lib/openai";
import { Character, Scene } from '@prisma/client';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

interface CharacterWithDetails extends Character {
  motivation: string | null;
  backstory: string | null;
  arc: string | null;
  relationships: string | null;
  goals: string | null;
  conflicts: string | null;
  personality: string | null;
  traits: string[];
}

export async function POST(
  req: NextRequest,
  { params }: { params: { projectId: string; sceneId: string } }
) {
  const { projectId, sceneId } = params;
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user?.id) {
      return NextResponse.json(
        { error: "Unauthorized" },
        { status: 401 }
      );
    }

    if (!projectId || !sceneId) {
      return NextResponse.json({ error: 'Project ID and Scene ID are required' }, { status: 400 });
    }

    const project = await prisma.project.findUnique({
      where: { id: projectId },
      select: { 
        userId: true, 
        language: true,
        structureType: true,
        characters: true
      },
    });

    if (!project || project.userId !== session.user.id) {
      return NextResponse.json({ error: 'Project not found or access denied' }, { status: 404 });
    }

    const scene = await prisma.scene.findUnique({
      where: { 
        id: sceneId,
        projectId: projectId
      }
    });

    if (!scene) {
      return NextResponse.json({ error: 'Scene not found' }, { status: 404 });
    }

    const characterDetails = (project.characters as CharacterWithDetails[]).map(char => ({
      name: char.name,
      description: char.description,
      motivation: char.motivation || '',
      backstory: char.backstory || '',
      arc: char.arc || '',
      relationships: char.relationships || '',
      goals: char.goals || '',
      conflicts: char.conflicts || '',
      personality: char.personality || '',
      traits: char.traits || []
    }));

    const prompt = `Write a screenplay scene based on the following details:

Scene Information:
Title: ${scene.title}
Summary: ${scene.summary}
Act: ${scene.act || 'Not specified'}
Location: ${(scene as any).location || 'Not specified'}
Time of Day: ${(scene as any).timeOfDay || 'Not specified'}
Scene Goals: ${(scene as any).goals || 'Not specified'}
Scene Conflicts: ${(scene as any).conflicts || 'Not specified'}

Characters:
${characterDetails.map(char => `
${char.name}:
- Description: ${char.description}
- Motivation: ${char.motivation}
- Backstory: ${char.backstory}
- Character Arc: ${char.arc}
- Relationships: ${char.relationships}
- Goals: ${char.goals}
- Conflicts: ${char.conflicts}
- Personality: ${char.personality}
- Traits: ${char.traits.join(', ')}
`).join('\n')}

Story Structure: ${project.structureType || 'three-act'}

Requirements:
1. Follow standard screenplay format
2. Include scene heading with location and time of day
3. Include character names in CAPS for dialogue
4. Include action descriptions
5. Include dialogue with proper formatting
6. Include parentheticals for character delivery
7. Include transitions if needed
8. Maintain proper screenplay margins and spacing
9. Include emotional beats and character reactions
10. Ensure dialogue reflects character personalities and goals

Write the scene in ${project.language || 'English'} language.`;

    const completion = await openai.chat.completions.create({
      model: 'gpt-4',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 2000,
      temperature: 0.7,
    });

    const generatedScript = completion.choices[0]?.message?.content;
    if (!generatedScript) {
      throw new Error('No script generated by OpenAI.');
    }

    // Update the scene with the generated script
    const updatedScene = await prisma.scene.update({
      where: {
        id: sceneId,
        projectId: projectId,
      },
      data: {
        script: generatedScript,
        version: scene.version + 1,
      },
    });

    if (completion.usage) {
      await trackTokenUsage({
        userId: session.user.id,
        projectId,
        model: completion.model,
        promptTokens: completion.usage.prompt_tokens,
        completionTokens: completion.usage.completion_tokens,
        totalTokens: completion.usage.total_tokens,
        type: 'script',
        operationName: 'Script Generation',
        cost: ((completion.usage.prompt_tokens / 1000) * 0.0005) + ((completion.usage.completion_tokens / 1000) * 0.0015)
      });
    }

    return NextResponse.json({ script: updatedScene.script });

  } catch (error) {
    console.error('[API - Generate Script] Error:', error);
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';
    return NextResponse.json({ error: errorMessage, details: error instanceof Error ? error.stack : null }, { status: 500 });
  }
} 